<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>5.6.2. Asynchronous sleep function and benchmarks &#8212; pyrpl 0.9.7.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bootstrap-sphinx.css?v=4468db6d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
    <script src="../../../_static/documentation_options.js?v=cf93a8f2"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../_static/icon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="5.6.3. How a spectrum is computed in PyRPL" href="../spectrum.html" />
    <link rel="prev" title="5.6.1. Requirements for an asynchronous interface compatible with python 3 asyncio" href="index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>

  </head><body>
  

  <style id="ribbon">
    #forkongithub a{background:#c11;color:#fff;text-decoration:none;font-family:arial,sans-serif;text-align:center;font-weight:bold;padding:5px 40px;font-size:1rem;line-height:2rem;position:relative;transition:0.5s;}
    #forkongithub a:hover{background:#1c1;color:#fff;}
    #forkongithub a::before,
    #forkongithub a::after{content:"";width:100%;display:block;position:absolute;top:1px;left:0;height:1px;background:#fff;}
    #forkongithub a::after{bottom:1px;top:auto;}@media screen and (min-width:800px)
    { #forkongithub{position:fixed;display:block;top:0;right:0;width:200px;overflow:hidden;height:200px;z-index:9999;}#forkongithub a{width:200px;position:absolute;top:45px;right:-45px;transform:rotate(45deg);-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);-moz-transform:rotate(45deg);-o-transform:rotate(45deg);box-shadow:4px 4px 10px rgba(0,0,0,0.8);}}
  </style>
  <span id="forkongithub"><a href="https://www.github.com/lneuhaus/pyrpl#fork-destination-box">Fork PyRPL on GitHub</a></span>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-102689373-2', 'auto');
    ga('send', 'pageview');

  </script>


  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          PyRPL</a>
        <span class="navbar-text navbar-version pull-left"><b>0.9.7.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../index.html">Home</a></li>
                <li><a href="../../../installation.html">Installation</a></li>
                <li><a href="../../../gui.html">Graphical user interface</a></li>
                <li><a href="../../../api.html">API</a></li>
                <li><a href="../../../basics.html">How PyRPL works</a></li>
                <li><a href="../../index.html">Infos for Developers</a></li>
            
            
              
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">5.6.2. Asynchronous sleep function and benchmarks</a><ul>
<li><a class="reference internal" href="#methods-compatible-with-python-2">5.6.2.1. Methods compatible with python 2:</a><ul>
<li><a class="reference internal" href="#the-normal-time-sleep-function-which-is-not-asynchronous">5.6.2.1.1. The normal time.sleep function (which is not asynchronous)</a></li>
<li><a class="reference internal" href="#constantly-calling-app-processevents">5.6.2.1.2. Constantly calling APP.processEvents()</a></li>
<li><a class="reference internal" href="#running-the-qeventloop-locally">5.6.2.1.3. Running the QEventLoop locally</a></li>
<li><a class="reference internal" href="#the-hybrid-approach">5.6.2.1.4. The hybrid approach</a></li>
<li><a class="reference internal" href="#benchmark-in-the-presence-of-other-events">5.6.2.1.5. Benchmark in the presence of other events</a><ul>
<li><a class="reference internal" href="#time-sleep">5.6.2.1.5.1. time.sleep</a></li>
<li><a class="reference internal" href="#calling-processevents">5.6.2.1.5.2. calling processEvents</a></li>
<li><a class="reference internal" href="#running-the-eventloop-locally">5.6.2.1.5.3. running the eventLoop locally</a></li>
<li><a class="reference internal" href="#our-custom-function">5.6.2.1.5.4. our custom function</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#async-programming-in-python3-5">5.6.2.2. Async programming in python3(.5):</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <section id="asynchronous-sleep-function-and-benchmarks">
<h1><span class="section-number">5.6.2. </span>Asynchronous sleep function and benchmarks<a class="headerlink" href="#asynchronous-sleep-function-and-benchmarks" title="Link to this heading">¶</a></h1>
<p>An asynchronous sleep function is highly desirable to let the GUI loop
(at the moment, the Qt event loop) run while pyrpl is waiting for curves
from the instruments.</p>
<p>The benchmark can be found in <a class="reference download internal" download="" href="../../../_downloads/6550e43a23d4081451efdb6179471891/timers.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">timers.ipynb</span></code></a>. It was
executed on python 3.5 on a windows 10 anaconda system.</p>
<section id="methods-compatible-with-python-2">
<h2><span class="section-number">5.6.2.1. </span>Methods compatible with python 2:<a class="headerlink" href="#methods-compatible-with-python-2" title="Link to this heading">¶</a></h2>
<p>We first compare 4 different implementations of the sleep function that
are all fully compatible between python 2 and python 3.</p>
<section id="the-normal-time-sleep-function-which-is-not-asynchronous">
<h3><span class="section-number">5.6.2.1.1. </span>The normal time.sleep function (which is not asynchronous)<a class="headerlink" href="#the-normal-time-sleep-function-which-is-not-asynchronous" title="Link to this heading">¶</a></h3>
<p>Calling time.sleep(delays) with delays ranging continuously from 0 to 5
ms gives the following distribution of measured delay vs requested
delay:</p>
<figure class="align-default">
<img alt="" src="../../../_images/time.sleep.png" />
</figure>
<p>As stated in the doc, sleep never returns before the requested delay,
however, it will try its best not to return more than 1 ms too late.
Moreover, we clearly have a problem because no qt events will be
processed since the main thread is blocked by the current execution of
time.sleep: for instance a timer’s timeout will only be triggered once
the sleep function has returned, this is what’s causing freezing of the
GUI when executing code in the jupyter console.</p>
</section>
<section id="constantly-calling-app-processevents">
<h3><span class="section-number">5.6.2.1.2. </span>Constantly calling APP.processEvents()<a class="headerlink" href="#constantly-calling-app-processevents" title="Link to this heading">¶</a></h3>
<p>The first work around, is to manually call processEvents() regularly to
make sure events are processed while our process is sleeping.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">timeit</span><span class="w"> </span><span class="kn">import</span> <span class="n">default_timer</span>

<span class="k">def</span><span class="w"> </span><span class="nf">sleep_pe</span><span class="p">(</span><span class="n">delay</span><span class="p">):</span>
    <span class="n">time0</span> <span class="o">=</span> <span class="n">default_timer</span><span class="p">()</span>
    <span class="k">while</span><span class="p">(</span><span class="n">default_timer</span><span class="p">()</span><span class="o">&lt;</span><span class="n">time0</span><span class="o">+</span><span class="n">delay</span><span class="p">):</span>
        <span class="n">APP</span><span class="o">.</span><span class="n">processEvents</span><span class="p">()</span>
</pre></div>
</div>
<p>first comment: we need to use timit.default_timer because time.time has
also a precision limited to the closest millisecond.</p>
<figure class="align-default">
<img alt="" src="../../../_images/processEvents.png" />
</figure>
<p>We get, as expected, an almost perfect correlation between requested
delays and obtained delays. Some outliers probably result from the OS
interrupting the current process execution, or even other events from
the GUI loop being executed just before the requested time.</p>
<p>We also see that the CPU load is quite high, even though we don’t do
anything but waiting for events. This is due to the loop constantly
checking for the current time and comparing it to the requested delay.</p>
</section>
<section id="running-the-qeventloop-locally">
<h3><span class="section-number">5.6.2.1.3. </span>Running the QEventLoop locally<a class="headerlink" href="#running-the-qeventloop-locally" title="Link to this heading">¶</a></h3>
<p>A better solution, as advertised
<a class="reference external" href="https://doc.qt.io/archives/qq/qq27-responsive-guis.html#waitinginalocaleventloop">here</a>,
is to run a new version of the QEventLoop locally:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">sleep_loop</span><span class="p">(</span><span class="n">delay</span><span class="p">):</span>
   <span class="n">loop</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QEventLoop</span><span class="p">()</span>
   <span class="n">timer</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QTimer</span><span class="p">()</span>
   <span class="n">timer</span><span class="o">.</span><span class="n">setInterval</span><span class="p">(</span><span class="n">delay</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>
   <span class="n">timer</span><span class="o">.</span><span class="n">setSingleShot</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
   <span class="n">timer</span><span class="o">.</span><span class="n">timeout</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">)</span>
   <span class="n">timer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
   <span class="n">loop</span><span class="o">.</span><span class="n">exec</span><span class="p">()</span> <span class="c1"># la loop prend en charge elle-même l&#39;évenement du timer qui va la faire mourir après delay.</span>
</pre></div>
</div>
<p>The subtlety here is that the loop.exec() function is blocking, and
usully would never return. To force it to return after some time delay,
we simply instanciate a QTimer and connect its timeout signal to the
quit function of the loop. The timer’s event is actually handled by the
loop itself. We then get a much smaller CPU load, however, we go back to
the situation where the intervals are only precise at the nearest
millisecond.</p>
<figure class="align-default">
<img alt="" src="../../../_images/qeventloop.png" />
</figure>
</section>
<section id="the-hybrid-approach">
<h3><span class="section-number">5.6.2.1.4. </span>The hybrid approach<a class="headerlink" href="#the-hybrid-approach" title="Link to this heading">¶</a></h3>
<p>A compromise is to use a QTimer that will stop 1 ms earlier, and then
manually call processEvents for the remaining time. We get at the same
time a low CPU load (as long as delay &gt;&gt; 1 ms, which is not completely
verified here), and a precise timing.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">my_sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">):</span>
    <span class="n">tic</span> <span class="o">=</span> <span class="n">default_timer</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">delay</span><span class="o">&gt;</span><span class="mf">1e-3</span><span class="p">:</span>
        <span class="n">sleep_loop</span><span class="p">(</span><span class="n">delay</span> <span class="o">-</span> <span class="mf">1e-3</span><span class="p">)</span>
    <span class="k">while</span><span class="p">(</span><span class="n">default_timer</span><span class="p">()</span><span class="o">&lt;</span><span class="n">tic</span><span class="o">+</span><span class="n">delay</span><span class="p">):</span>
        <span class="n">APP</span><span class="o">.</span><span class="n">processEvents</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="" src="../../../_images/my_sleep.png" />
</figure>
</section>
<section id="benchmark-in-the-presence-of-other-events">
<h3><span class="section-number">5.6.2.1.5. </span>Benchmark in the presence of other events<a class="headerlink" href="#benchmark-in-the-presence-of-other-events" title="Link to this heading">¶</a></h3>
<p>To simulate the fact that in real life, other events have to be treated
while the loop is running (for instance, user interactions with the GUI,
or another instrument running an asynchronous measurement loop), we run
in parallel the following timer:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">PyQt4</span><span class="w"> </span><span class="kn">import</span> <span class="n">QtCore</span><span class="p">,</span> <span class="n">QtGui</span>
<span class="n">n_calc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate</span><span class="p">():</span>
    <span class="n">sin</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
    <span class="n">n_calc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">timer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">timer</span> <span class="o">=</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">QTimer</span><span class="p">()</span>
<span class="n">timer</span><span class="o">.</span><span class="n">setInterval</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">timer</span><span class="o">.</span><span class="n">setSingleShot</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">timer</span><span class="o">.</span><span class="n">timeout</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">calculate</span><span class="p">)</span>
</pre></div>
</div>
<p>By looking at how fast <code class="docutils literal notranslate"><span class="pre">n_calc[0]</span></code> gets incremented, we can measure
how blocking our sleep-function is for other events. We get the
following outcomes (last number “calc/s” in the figure title):</p>
<section id="time-sleep">
<h4><span class="section-number">5.6.2.1.5.1. </span>time.sleep<a class="headerlink" href="#time-sleep" title="Link to this heading">¶</a></h4>
<p>As expected, time.sleep prevents any event from being processed</p>
<figure class="align-default">
<img alt="" src="../../../_images/time.sleep1.png" />
</figure>
</section>
<section id="calling-processevents">
<h4><span class="section-number">5.6.2.1.5.2. </span>calling processEvents<a class="headerlink" href="#calling-processevents" title="Link to this heading">¶</a></h4>
<p>40 000 events/seconds.</p>
<figure class="align-default">
<img alt="" src="../../../_images/processEvents1.png" />
</figure>
</section>
<section id="running-the-eventloop-locally">
<h4><span class="section-number">5.6.2.1.5.3. </span>running the eventLoop locally<a class="headerlink" href="#running-the-eventloop-locally" title="Link to this heading">¶</a></h4>
<figure class="align-default">
<img alt="" src="../../../_images/qeventloop1.png" />
</figure>
<p>That’s approximately identical</p>
</section>
<section id="our-custom-function">
<h4><span class="section-number">5.6.2.1.5.4. </span>our custom function<a class="headerlink" href="#our-custom-function" title="Link to this heading">¶</a></h4>
<p>Still more or less identical (but remember that the big advantage
compared to the previous version is that in the absence of external
events, the CPU load is close to 0).</p>
<figure class="align-default">
<img alt="" src="../../../_images/my_sleep1.png" />
</figure>
</section>
</section>
</section>
<section id="async-programming-in-python3-5">
<h2><span class="section-number">5.6.2.2. </span>Async programming in python3(.5):<a class="headerlink" href="#async-programming-in-python3-5" title="Link to this heading">¶</a></h2>
<p>A description of async programming in python 3.5 is given in
“<a class="reference internal" href="index.html"><span class="doc">Requirements for an asynchronous interface compatible with python 3 asyncio</span></a>”. To summarize, it is possible to use the Qt event loop as
a backend for the beautiful syntax of coroutines in python 3 using
quamash. Of course, because the quamash library is just a wrapper
translating the new python asynchronous syntax into QTimers, there is no
magic on the precision/efficiency side: for instance, the basic
coroutine <code class="docutils literal notranslate"><span class="pre">asyncio.sleep</span></code> gives a result similar to “Running a local
QEventLoop”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">sleep_coroutine</span><span class="p">(</span><span class="n">delay</span><span class="p">):</span>
   <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="" src="../../../_images/asyncio_no_correction.png" />
</figure>
<p>But, obviously, we can play the same trick as before to make a precise
enough coroutine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">sleep_coroutine</span><span class="p">(</span><span class="n">delay</span><span class="p">):</span>
   <span class="n">tic</span> <span class="o">=</span> <span class="n">default_timer</span><span class="p">()</span>
   <span class="k">if</span> <span class="n">delay</span><span class="o">&gt;</span><span class="mf">0.001</span><span class="p">:</span>
       <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span> <span class="o">-</span> <span class="mf">0.001</span><span class="p">)</span>
   <span class="k">while</span> <span class="n">default_timer</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tic</span> <span class="o">+</span> <span class="n">delay</span><span class="p">:</span>
       <span class="n">APP</span><span class="o">.</span><span class="n">processEvents</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="" src="../../../_images/asyncio.png" />
</figure>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../../../_sources/developer_guide/api/asynchronous/benchmark.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2014-2025, Leonhard Neuhaus, Samuel Deléglise, Michaël Croquette .<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.4.7.<br/>
    </p>
  </div>
</footer>
  </body>
</html>
<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>5.6.3. How a spectrum is computed in PyRPL &#8212; pyrpl 0.9.7.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sphinx.css?v=4468db6d" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />
    <script src="../../_static/documentation_options.js?v=cf93a8f2"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../_static/icon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="5.6.4. MemoryTree" href="memory_tree.html" />
    <link rel="prev" title="5.6.2. Asynchronous sleep function and benchmarks" href="asynchronous/benchmark.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>

  </head><body>
  

  <style id="ribbon">
    #forkongithub a{background:#c11;color:#fff;text-decoration:none;font-family:arial,sans-serif;text-align:center;font-weight:bold;padding:5px 40px;font-size:1rem;line-height:2rem;position:relative;transition:0.5s;}
    #forkongithub a:hover{background:#1c1;color:#fff;}
    #forkongithub a::before,
    #forkongithub a::after{content:"";width:100%;display:block;position:absolute;top:1px;left:0;height:1px;background:#fff;}
    #forkongithub a::after{bottom:1px;top:auto;}@media screen and (min-width:800px)
    { #forkongithub{position:fixed;display:block;top:0;right:0;width:200px;overflow:hidden;height:200px;z-index:9999;}#forkongithub a{width:200px;position:absolute;top:45px;right:-45px;transform:rotate(45deg);-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);-moz-transform:rotate(45deg);-o-transform:rotate(45deg);box-shadow:4px 4px 10px rgba(0,0,0,0.8);}}
  </style>
  <span id="forkongithub"><a href="https://www.github.com/lneuhaus/pyrpl#fork-destination-box">Fork PyRPL on GitHub</a></span>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-102689373-2', 'auto');
    ga('send', 'pageview');

  </script>


  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          PyRPL</a>
        <span class="navbar-text navbar-version pull-left"><b>0.9.7.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../index.html">Home</a></li>
                <li><a href="../../installation.html">Installation</a></li>
                <li><a href="../../gui.html">Graphical user interface</a></li>
                <li><a href="../../api.html">API</a></li>
                <li><a href="../../basics.html">How PyRPL works</a></li>
                <li><a href="../index.html">Infos for Developers</a></li>
            
            
              
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">5.6.3. How a spectrum is computed in PyRPL</a><ul>
<li><a class="reference internal" href="#definitions">5.6.3.1. Definitions</a></li>
<li><a class="reference internal" href="#sinusoidal-input">5.6.3.2. Sinusoidal input</a></li>
<li><a class="reference internal" href="#white-noise-input">5.6.3.3. White noise input</a></li>
<li><a class="reference internal" href="#iq-mode">5.6.3.4. IQ mode</a></li>
<li><a class="reference internal" href="#baseband">5.6.3.5. Baseband</a></li>
<li><a class="reference internal" href="#proposal-for-a-cleaner-interface-for-spectrum-analyzer">5.6.3.6. Proposal for a cleaner interface for spectrum analyzer:</a></li>
<li><a class="reference internal" href="#iq-mode-with-proper-anti-aliasing-filter">5.6.3.7. IQ mode with proper anti-aliasing filter</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <section id="how-a-spectrum-is-computed-in-pyrpl">
<h1><span class="section-number">5.6.3. </span>How a spectrum is computed in PyRPL<a class="headerlink" href="#how-a-spectrum-is-computed-in-pyrpl" title="Link to this heading">¶</a></h1>
<p>Inspiration comes from Oppenheim &amp; Schaefer 1975 and from
<a class="reference external" href="http://cp.literature.agilent.com/litweb/pdf/5952-0292.pdf">Agilent</a></p>
<p>The spectrum analyzer in Pyrpl estimates the spectrum of internal or
external signals by performing Fast-Fourier Transforms of traces
recorded by the scope. Since in the current version of Pyrpl, the stream
of data from the scope is made of discontiguous segments of 2^14
samples, we are currently using the
<a class="reference external" href="https://en.wikipedia.org/wiki/Bartlett%27s_method">Bartlett</a> method,
which consists in the following steps:</p>
<ol class="arabic simple">
<li><p>Each segment is multiplied by a symmetric window function of the same
size.</p></li>
<li><p>The DFT of individual segments is performed. The segment is padded
before the FFT by a number of 0s to provide more points in the estimated
spectrum than in the original time segment.</p></li>
<li><p>The square modulus of the resulting periodograms are averaged to give
the estimate of the spectrum, with the same size as the initial
time-segments.</p></li>
</ol>
<p>A variant of this method is the
<a class="reference external" href="https://en.wikipedia.org/wiki/Welch%27s_method">Welch</a> method, in
which the segments are allowed to be overlapping with each other. The
advantage is that when a narrow windowing function (ie a large number of
“points-per-bandwidth” in the frequency domain) is used, the points far
from the center of the time-segments have basically no weight in the
result. With overlapping segments, it is basically possible to move the
meaningful part of the window over all the available data. This is the
basic principle of real-time spectrum analyzers. This cannot be
implemented “as is” since the longest adjacent time-traces at our
disposal is 2^14 sample long.</p>
<p>However, a possible improvement, which would not require any changes of
the underlying FPGA code would be to apply the welch method with
subsegments smaller than the initial scope traces: for instance we would
extract 2^13 points subsegments, and we could shift the subsegment by up
to 2^13 points. With such a method, even with an infinitely narrow
windowing function, we would only “loose” half of the acquired data.
This could be immediately implemented with the Welch method implemented
in
<a class="reference external" href="https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.signal.welch.html">scipy</a>.</p>
<p>In the following, we discuss the normalization of windowing functions,
and then, the basic principle of operation of the two modes “iq” and
“baseband”.</p>
<section id="definitions">
<h2><span class="section-number">5.6.3.1. </span>Definitions<a class="headerlink" href="#definitions" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>name</p></th>
<th class="head"><p>definition</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Original time series</p></td>
<td><p>x[k], 0&lt;=k&lt;N</p></td>
</tr>
<tr class="row-odd"><td><p>Fourier Transform</p></td>
<td><p>X[r] = sum_k x[k] exp(-2 i pi r k/N)</p></td>
</tr>
<tr class="row-even"><td><p>Inverse Fourier Transform (equivalently)</p></td>
<td><p>x[k] = 1/N sum_r X[r] exp(2 i pi k r/N)</p></td>
</tr>
<tr class="row-odd"><td><p>Time window</p></td>
<td><p>w[k]</p></td>
</tr>
<tr class="row-even"><td><p>Fourier transformed time window</p></td>
<td><p>W[r]</p></td>
</tr>
<tr class="row-odd"><td><p>Singly averaged spectrum (in V_pk)</p></td>
<td><p>Y[r]=sum_k x[k] w[k] exp(-2 i pi r k/N)</p></td>
</tr>
<tr class="row-even"><td><p>Singly averaged spectrum (in Vrms^2/Hz)</p></td>
<td><p>Z(r) = |Y(r)|^2/ (2 rbw)</p></td>
</tr>
</tbody>
</table>
<p>We can show that the Fourier transform of the product is the convolution of the Fourier
Transforms, such that:</p>
<p>Y[r] = 1/N sum_r’ X[r’] W[r-r’]     (1)</p>
<p>To make sure the windowing function is well normalized, and to define
the noise equivalent bandwidth of a given windowing function,
we will study the 2 limiting cases where the initial time series is either
a sinusoid or a gaussian distributed white noise.</p>
</section>
<section id="sinusoidal-input">
<h2><span class="section-number">5.6.3.2. </span>Sinusoidal input<a class="headerlink" href="#sinusoidal-input" title="Link to this heading">¶</a></h2>
<p>To simplify the calculations, we assume the period of the sinusoid is a multiple
of the sampling rate:</p>
<p>x[k] = cos[2 pi m k/N]</p>
<p>= 1/2 (exp[i 2 pi m k/N] + exp[-2 pi i (N - m) k/N])</p>
<p>We obtain the Fourier transform:</p>
<p>X[r] = N/2 (delta[r-m] + delta[r-(N-m)]).</p>
<p>We deduce using (1), that the estimated spectrum is:</p>
<p>Y[r] = 1/2 (W[r - m] + W[r - (N-m)])</p>
<p>With the discrete fourier transform convention used here, we need to pay attention that
the DC-component is for r=0, and the ?negative frequencies? are actually located in the second
half of the interval [N/2, N]. If we take the single sided convention where the negative frequency
side is simply ignored, the correct normalization in terms of V_pk (for which the maximum of the
spectrum corresponds to the amplitude of the sinusoid) is the one for where max(W[r]) = 2.</p>
<p>Moreover, a reasonable windowing function will only have non-zero Fourier components on the few bins
around DC, such that if we measure a pure sinusoid with a frequency far from 0, there wont be any significant
overlap between the two terms, and we will measure 2 distinct peaks in the positive and negative
frequency regions, each of them with the shape of the Fourier transform of the windowing function.
Since the maximum of W[r] is located in r=0, we finally have:</p>
<p>sum_k w[k] = 2</p>
</section>
<section id="white-noise-input">
<h2><span class="section-number">5.6.3.3. </span>White noise input<a class="headerlink" href="#white-noise-input" title="Link to this heading">¶</a></h2>
<p>Once the normalization of the filter window has been imposed by the previous condition,
we need to define the bandwidth of the window such that noise measurements integrated
over frequency give the right variances.</p>
<p>Let’s take a white noise of variance 1.</p>
<p>&lt;x[k] x[k’]&gt; = delta(k-k’).</p>
<p>We would like the total spectrum in units of Vrms^2/Hz, integrated from 0 to Nyquist frequency
to yield the same variance of 1. This is ensured by the Equivalent noise bandwidth of the filter window.
To convert from V_pk^2 to V_rms^2/Hz, the spectrum is divided by the residual bandwidth of the filter window.</p>
<p>Let’s calculate:</p>
<p>sum_r &lt;<a href="#id1"><span class="problematic" id="id2">|</span></a>Y[r]|^2&gt; = (…) = N sum_k w[k]^2 &lt;<a href="#id3"><span class="problematic" id="id4">|</span></a>x[k]|^2&gt;</p>
<p>If we remind that x[k] is a white noise following &lt;<a href="#id5"><span class="problematic" id="id6">|</span></a>x[k]|^2&gt; = 1, we get:</p>
<p>sum_r &lt;<a href="#id7"><span class="problematic" id="id8">|</span></a>Y[r]|^2&gt; = N sum_k w[k]^2</p>
<p>So, since we want:</p>
<p>sum_r &lt;<a href="#id9"><span class="problematic" id="id10">|</span></a>Z[r]|^2&gt; df = 2, (indeed, we want to work with single-sided spectra, such that integrating over positive frequencies is enough)</p>
<p>with df the frequency step in the FFT, we need to choose:</p>
<p>rbw = N sum_k w[k]^2 df /4</p>
<p>In order to use dimensionless parameters for the filter windows, we can introduce the equivalent noise bandwidth:</p>
<p>ENBW = sum_k w[k]^2/(sum_k w[k])^2 = 1/4 sum_k w[k]^2</p>
<p>Finally, we get the expression of the rbw:</p>
<p>rbw = sample_rate ENBW</p>
</section>
<section id="iq-mode">
<h2><span class="section-number">5.6.3.4. </span>IQ mode<a class="headerlink" href="#iq-mode" title="Link to this heading">¶</a></h2>
<p>In iq mode, the signal to measure is fed inside an iq module, and thus,
multiplied by two sinusoids in quadrature with each other, and at the
frequency <code class="docutils literal notranslate"><span class="pre">center_freq</span></code>. The resulting I and Q signals are then
filtered by 4 first order filters in series with each other, with cutoff
frequencies given by <code class="docutils literal notranslate"><span class="pre">span</span></code>. Finally, these signals are measured
simultaneously with the 2 channels of the scope, and we form the complex
time serie c_n = I_n + i Q_n. The procedure described above is
applied to extract the periodogram from the complex time-serie.</p>
<p>Since the data are complex, there are as many independent values in the
FFT than in the initial data (in other words, negative frequencies are
not redundant with positive frequency). In fact, the result is an
estimation of the spectrum in the interval [center_freq - span/2,
center_freq + span/2].</p>
</section>
<section id="baseband">
<h2><span class="section-number">5.6.3.5. </span>Baseband<a class="headerlink" href="#baseband" title="Link to this heading">¶</a></h2>
<p>In baseband mode, the signal to measure is directly fed to the scope and
the procedure described above is applied directly. There are 2
consequences of the fact that the data are real:</p>
<ol class="arabic simple">
<li><p>The negative frequency components are complex conjugated (and thus
redundant) wrt the positive ones. We thus throw away the negative
frequencies, and only get a measurement on the interval [0, span/2]</p></li>
<li><p>The second scope channel can be used to measure another signal.</p></li>
</ol>
<p>It is very interesting to measure simultaneously 2 signals, because we
can look for correlations between them. In the frequency domains, these
correlations are most easily represented by the cross-spectrum. We
estimate the cross-spectrum by performing the product
<code class="docutils literal notranslate"><span class="pre">conjugate(fft1)*fft2</span></code>, where <code class="docutils literal notranslate"><span class="pre">fft1</span></code> and <code class="docutils literal notranslate"><span class="pre">fft2</span></code> are the DFTs of
the individual scope channels before taking their modulus square.</p>
<p>Hence, in baseband mode, the method <code class="docutils literal notranslate"><span class="pre">curve()</span></code> returns a 4x2^13 array
with the following content: - spectrum1 - spectrum2 - real part of cross
spectrum - imaginary part of cross spectrum</p>
</section>
<section id="proposal-for-a-cleaner-interface-for-spectrum-analyzer">
<h2><span class="section-number">5.6.3.6. </span>Proposal for a cleaner interface for spectrum analyzer:<a class="headerlink" href="#proposal-for-a-cleaner-interface-for-spectrum-analyzer" title="Link to this heading">¶</a></h2>
<p>To avoid baseband/2-channels acquisition from becoming a big mess, I
suggest the following:</p>
<ul class="simple">
<li><p>The return type of the method <code class="docutils literal notranslate"><span class="pre">curve</span></code> should depend as little as
possible from the particular settings of the instrument
(<code class="docutils literal notranslate"><span class="pre">channel2_baseband_active</span></code>, <code class="docutils literal notranslate"><span class="pre">display_units</span></code>). That was the idea
with scope, and I think that makes things much cleaner.
Unfortunately, for <code class="docutils literal notranslate"><span class="pre">baseband</span></code>, making 2 parallel piplines such as
<code class="docutils literal notranslate"><span class="pre">curve_iq</span></code>, <code class="docutils literal notranslate"><span class="pre">curve_baseband</span></code> is not so trivial, because
<code class="docutils literal notranslate"><span class="pre">curve()</span></code> is already part of the <code class="docutils literal notranslate"><span class="pre">AcquisitionModule</span></code>. So I think
we will have to live with the fact that <code class="docutils literal notranslate"><span class="pre">curve()</span></code> returns 2
different kinds of data in <code class="docutils literal notranslate"><span class="pre">baseband</span></code> and <code class="docutils literal notranslate"><span class="pre">iq-mode</span></code>.</p></li>
<li><p>Moreover, in baseband, we clearly want both individual spectra +
cross-spectrum to be calculated from the beginning, since once the
<code class="docutils literal notranslate"><span class="pre">abs()</span></code> of the <code class="docutils literal notranslate"><span class="pre">ffts</span></code> is taken, it is already too late to compute
<code class="docutils literal notranslate"><span class="pre">conjugate(fft1)*fft2</span></code></p></li>
<li><p>Finally, I suggest to return all spectra with only one “internal
unit” which would be <code class="docutils literal notranslate"><span class="pre">V_pk^2</span></code>: indeed, contrary to rms-values
unittesting doesn’t require any conversion with peak values,
moreover, averaging is straightforward with a quadratic unit,
finally, <code class="docutils literal notranslate"><span class="pre">.../Hz</span></code> requires a conversion-factor involving the
bandwidth for unittesting with coherent signals</p></li>
</ul>
<p>I suggest the following return values for <code class="docutils literal notranslate"><span class="pre">curve()</span></code>:</p>
<ul class="simple">
<li><p>In normal (iq-mode): <code class="docutils literal notranslate"><span class="pre">curve()</span></code> returns a real valued 1D-array with
the normal spectrum in <code class="docutils literal notranslate"><span class="pre">V_pk^2</span></code></p></li>
<li><p>In baseband: <code class="docutils literal notranslate"><span class="pre">curve()</span></code> returns a 4xN/2-real valued array with
<code class="docutils literal notranslate"><span class="pre">(spectrum1,</span> <span class="pre">spectrum2,</span> <span class="pre">cross_spectrum_real,</span> <span class="pre">cross_spectrum_imag)</span></code>.
Otherwise, manipulating a complex array for the 2 real spectra is
painful and inefficient.</p></li>
</ul>
<p>Leo: Seems okay to me. One can always add functions like spectrum1() or
cross_spectrum_complex() which will take at most two lines. Same for
the units, I won’t insist on rms, its just a matter of multiplying
sqrt(1/2). However, I suggest that we then have 3-4 buttons in the gui
to select which spectra and cross-spectra are displayed.</p>
<p>Yes, I am actually working on the gui right now: There will be a
baseband-area, where one can choose <code class="docutils literal notranslate"><span class="pre">display_input1_baseband</span></code>,
<code class="docutils literal notranslate"><span class="pre">input1_baseband</span></code>, <code class="docutils literal notranslate"><span class="pre">display_input2_baseband</span></code>, <code class="docutils literal notranslate"><span class="pre">input2_baseband</span></code>,
<code class="docutils literal notranslate"><span class="pre">display_cross_spectrum</span></code>, ‘display_cross_spectrum_phase’. And a
“iq-area” where one can choose <code class="docutils literal notranslate"><span class="pre">center_frequency</span></code> and <code class="docutils literal notranslate"><span class="pre">input</span></code>. I
guess this is no problem if we have the 3 distinct attributes <code class="docutils literal notranslate"><span class="pre">input</span></code>,
<code class="docutils literal notranslate"><span class="pre">input1_baseband</span></code> and <code class="docutils literal notranslate"><span class="pre">input2_baseband</span></code>, it makes thing more
symmetric…</p>
</section>
<section id="iq-mode-with-proper-anti-aliasing-filter">
<h2><span class="section-number">5.6.3.7. </span>IQ mode with proper anti-aliasing filter<a class="headerlink" href="#iq-mode-with-proper-anti-aliasing-filter" title="Link to this heading">¶</a></h2>
<p>When the IQ mode is used, a part of the broadband spectrum of the two
quadratures is to be sampled at a significantly reduced sampling rate in
order to increase the number of points in the spectrum, and thereby
resolution bandwidth. Aliasing occurs if significant signals above the
scope sampling rate are thereby under-sampled by the scope, and results
in ghost peaks in the spectrum. The ordinary way to get rid of this
effect is to use excessive digital low-pass filtering with cutoff
frequencies slightly below the scope sampling rate, such that any peaks
outside the band of interest will be rounded off to zero. The following
code implements the design of such a low-pass filter (we choose an
elliptical filter for maximum steepness):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># the overall decimation value</span>
<span class="n">decimation</span> <span class="o">=</span> <span class="mi">8</span>

<span class="c1"># elliptical filter runs at ell_factor times the decimated scope sampling rate</span>
<span class="n">ell_factor</span> <span class="o">=</span> <span class="mi">4</span>

<span class="n">wp</span> <span class="o">=</span> <span class="mf">0.8</span><span class="o">/</span><span class="n">ell_factor</span> <span class="c1"># passband ends at xx% of nyquist frequency</span>
<span class="n">ws</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">ell_factor</span> <span class="c1"># stopband starts at yy% of nyquist frequency</span>
<span class="n">gpass</span> <span class="o">=</span> <span class="mf">5.</span> <span class="c1"># jitter in passband (dB)</span>
<span class="n">gstop</span> <span class="o">=</span> <span class="mf">20.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># attenuation in stopband (dB)</span>
<span class="c1">#gstop = 60  #60 dB attenuation would only require a 6th order filter</span>
<span class="n">N</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">ellipord</span><span class="p">(</span><span class="n">wp</span><span class="o">=</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="o">=</span><span class="n">ws</span><span class="p">,</span> <span class="n">gpass</span><span class="o">=</span><span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="o">=</span><span class="n">gstop</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># get filter order</span>
<span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">ellip</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;zpk&#39;</span><span class="p">)</span>  <span class="c1"># get coefficients for implementation</span>
<span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">ellip</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;ba&#39;</span><span class="p">)</span>  <span class="c1"># get coefficients for plotting</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">freqz</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">worN</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="p">)</span>
<span class="n">ww</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">62.5</span>  <span class="c1"># scale factor for frequency axis (original frequency axis goes up to 2 pi)</span>

<span class="c1"># extent w to see what happens at higher frequencies</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">decimation</span><span class="o">/</span><span class="n">ell_factor</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># fold the response of the elliptical filter</span>
<span class="n">hext</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">decimation</span><span class="o">/</span><span class="n">ell_factor</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">hext</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hext</span> <span class="o">+=</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hext</span><span class="p">)</span>
<span class="c1"># elliptical filter</span>
<span class="n">h_abs</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>

<span class="c1"># 4th order lowpass filter after IQ block with cutoff of decimated scope sampling rate</span>
<span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">decimation</span>
<span class="n">butter</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span><span class="o">/</span><span class="n">cutoff</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span>
<span class="n">butter_abs</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">butter</span><span class="p">))</span>

<span class="c1"># moving average decimation filter</span>
<span class="n">M</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">decimation</span><span class="p">)</span> <span class="c1"># moving average filter length</span>
<span class="n">mavg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
<span class="n">mavg_abs</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">mavg</span><span class="p">))</span>

<span class="c1"># plot everything together and individual parts</span>
<span class="n">h_tot</span> <span class="o">=</span> <span class="n">h_abs</span> <span class="o">+</span> <span class="n">mavg_abs</span> <span class="o">+</span> <span class="n">butter_abs</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">ww</span><span class="p">,</span> <span class="n">h_tot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">ww</span><span class="p">,</span> <span class="n">h_abs</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;elliptic filter&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">ww</span><span class="p">,</span> <span class="n">butter_abs</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;butterworth filter&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">ww</span><span class="p">,</span> <span class="n">mavg_abs</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;moving average filter&quot;</span><span class="p">)</span>


<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Elliptical lowpass filter of order </span><span class="si">%d</span><span class="s1">, decimation </span><span class="si">%d</span><span class="s1">, ell_factor </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">decimation</span><span class="p">,</span> <span class="n">ell_factor</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (MHz)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (dB)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill</span><span class="p">([</span><span class="n">ws</span><span class="o">/</span><span class="n">ww</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">decimation</span><span class="o">*</span><span class="n">ell_factor</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">ww</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">ww</span><span class="p">),</span> <span class="n">ws</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">ww</span><span class="o">/</span><span class="n">decimation</span><span class="o">*</span><span class="n">ell_factor</span><span class="p">],</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">h_abs</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">h_abs</span><span class="p">),</span> <span class="o">-</span><span class="n">gstop</span><span class="p">,</span> <span class="o">-</span><span class="n">gstop</span><span class="p">],</span> <span class="s1">&#39;0.9&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># stop</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill</span><span class="p">([</span><span class="n">wp</span><span class="o">/</span><span class="n">ww</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">decimation</span><span class="o">*</span><span class="n">ell_factor</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">ww</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">ww</span><span class="p">),</span> <span class="n">wp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">ww</span><span class="o">/</span><span class="n">decimation</span><span class="o">*</span><span class="n">ell_factor</span><span class="p">],</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">h_abs</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">h_abs</span><span class="p">),</span> <span class="o">-</span><span class="n">gpass</span><span class="p">,</span> <span class="o">-</span><span class="n">gpass</span><span class="p">],</span> <span class="s1">&#39;0.9&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># stop</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">ww</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">ww</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">h_abs</span><span class="p">)</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">h_abs</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;c://lneuhaus//github//pyrpl//doc//specan_filter.png&#39;</span><span class="p">,</span><span class="n">DPI</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>

<span class="nb">print</span> <span class="s2">&quot;Final biquad coefficients [b0, b1, b2, a0, a1, a2]:&quot;</span>
<span class="k">for</span> <span class="n">biquad</span> <span class="ow">in</span> <span class="n">signal</span><span class="o">.</span><span class="n">zpk2sos</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">biquad</span>
</pre></div>
</div>
<figure class="align-default" id="id11">
<img alt="Resulting filter" src="https://github.com/lneuhaus/pyrpl/blob/master/doc/specan_filter.png" />
<figcaption>
<p><span class="caption-text">Resulting filter</span><a class="headerlink" href="#id11" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>We see that a filter of 8th order, consisting of 4 sequential biquads is
required. Since we do not require the span / sampling rate of the
spectrum analyzer to be above roughly 5 MHz, we may implement the four
biquads sequentially. Furthermore, for even lower values of the span,
the filter can be fed with a reduced clock rate equal to the scope
decimation factor divided by the variable ‘decimation’ in the filter
design code above (4 in the example). For the aliasing of the lowpass
filter passband not to cause problems in this case, we must in addition
use the 4th order butterworth lowpass already available from the IQ
module and the moving average filter of the scope. Then, as the plot
shows, we can be sure that no aliasing occurs, given that no aliasing
from the ADCs is present (should be guaranteed by analog Red Pitaya
design).</p>
<p>The problem with our scheme is the complexity of introducing 2 (for the
two quadratures) 4-fold biquads. This will not fit into the current
design and must therefore be postponed to after the FPGA cleanup.</p>
<p>We could however opt for another temporary option, applicable only to
stationary signals: Measure the spectrum twice or thrice with slightly
shifted IQ demodulation frequency (at +- 10% of span and the actual
center, as required above), and only plot the pointwise-minimum (with
respect to the final frequency axis) of the obtained traces. This is
simple and should be very effective (also to reduce the central peak at
the demodulation freuqency), so i suggest we give it a try. Furthermore,
it prepares the user that IQ spectra will only have 80% of the points in
baseband mode, which will remain so after the implementation of the
lowpass filter. The plot above shows that we do not have to worry about
aliasing from multiple spans away if the bandwidth if the IQ module is
se to the scope sampling rate (or slightly below). I am not aware that
this method is used anywhere else, but do not see any serious problem
with it.</p>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../../_sources/developer_guide/api/spectrum.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2014-2025, Leonhard Neuhaus, Samuel Deléglise, Michaël Croquette .<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.4.7.<br/>
    </p>
  </div>
</footer>
  </body>
</html>